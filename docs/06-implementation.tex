\chapter{Технологическая часть}
В данном разделе обоснован выбор средств разработки ПО.

\section{Средства разработки}
Для разработки ПО выбран язык \texttt{Python} \cite{python}.
Данный язык программирования поддерживает объектно-ориентированнный подход и является интерпретируемым, что позволяет применять его в качестве скриптового встраиваемого языка.

В качестве инструмента для кодогенерации выбрана утилита \texttt{Cog} \cite{cog}, позволяющая производить запуск кода на \texttt{Python} в качестве этапа предобработки исходного кода на другом языке программирования при размещении его в комментариях специального формата.

Для произведения предварительного анализа текста SQL-выражений используется инструмент распознавания языков \texttt{ANTLR} \cite{antlr}, при помощи которого сгенерированы файлы исходного кода лексического и синтаксического анализаторов, а также базовый класс посетителя абстрактного синтаксического дерева на основе свободно распространяемых грамматик SQLite \cite{antlr_grammars}.

В качестве среды разработки выбрана PyCharm -- кросплатформенная IDE для \texttt{Python}, предоставляющая бесплатную лицензию студентам и хорошо знакомая мне, поскольку использовалась во время работы и учебы \cite{pycharm}.

Доступа к вычислительному комплексу Тераграф осуществляется с использованием облачной платформы Тераграф Cloud, обеспечивающей одновременный доступ многих пользователей к ядрам, входящим в состав микропроцессора Леонард Эйлер \cite{teragraph_cloud}.

Для подключения к платформе использовалась веб-версия IDE Visual Studio Code \cite{vscode}, запуск которой осуществляется при помощи подключения к серверу JupyterHub \cite{jupyter}.

\section{Формирование набора данных о SQL-выражении}
За формирование набора данных о SQL-выражении отвечает класс посетителя, точка входа которого приведена в листинге \ref{lst:visit_sql.py}.

В данном методе происходит обработка всех трех поддерживаемых типов SQL-выражений.

\includelisting
{visit_sql.py}
{Исходный код точки входа посетителя}

Функция сбора данных о выражении создания таблицы сохраняет название таблицы, информацию о первичном ключе и список столбцов таблицы с метаданными об их типе и размере в байтах.
Исходный код функции представлен в листинге \ref{lst:visit_create.py}.

\includelistingpretty
{visit_create.py}
{Python}
{Исходный код функции посещения выражения \texttt{CREATE TABLE}}

Для получения информации о типе данных столбца используется вспомогательный класс \texttt{TypeConverter}, преобразующий имя типа в данные о нём, что показано в листинге \ref{lst:type_converter.py}.

При этом обеспечивается поддержка нескольких видов задания числовых типов данных, напрямую по их размерам в байтах, либо по более удобным для человека именам.

\includelistingpretty
{type_converter.py}
{Python}
{Исходный код класса преобразования типов}

Функция сбор аданных о выражении выборки данных сохраняет информацию о запрошенных столбцах таблицы и их псеводнимах, что показано в листинге \ref{lst:visit_select.py}.

Также в контекст запроса выборки данных сохраняются таблицы, использованные в запросе.

\includelistingpretty
{visit_select.py}
{Python}
{Исходный код функции посещения выражения \texttt{SELECT}}

При сборе данных о выражении вставки необходимо сохранить все вставляемые строки и их содержание -- листинг \ref{lst:visit_insert.py}.

\includelistingpretty
{visit_insert.py}
{Python}
{Исходный код функции посещения выражения \texttt{INSERT}}

Все встреченные значения, к которым относятча числовые литералы и связываемые параметры также сохраняются для дальнейшего использования при преобразовании выражений.

Отдельно сохраняются литералы, связываемые параметры и все значения в порядке следования в SQL-выражении, что позволяет подставлять их как при преобразовании \texttt{SELECT} (в качестве значений регистров), так и \texttt{INSERT} выражений (в качестве параметров функции вставки) -- листинг \ref{lst:exprs.py}.

\includelistingpretty
{exprs.py}
{Python}
{Исходный код функции посещения значений}

\section{Преобразование SQL-выражений}
В данном разделе описаны реализованные алгоритмы преоборазования набора данных об SQL-выражении в текст на языке \texttt{C++}, а также необходимых для их реализации вспомогательных функций.

\subsection{Создание таблицы}
Для объявления структуры хранения данных при работе с библитекой \texttt{leonhard x64 xrt} необходимо создать структуру языка \texttt{C++}, содержащую объявления пар ключ-значение и описание их состава.
При этом накладывается ограничение на размер ключа и значения -- ровно 64 бита \cite{teragraph}.

Однако существует метод расширения структур, позволяющий хранить записи большего размера путем разбиение их на группы и создания множества ключей, отличающихся старшими битами.

Для преобразования данных о столбцах в набор ключей и значений применяется последовательное заполнение групп, пока новый столбец не приведёт к превышению максимального размера структуры значения группы, в этом случае происходит создание новой группы.

Каждая полученная группа преобразуется в пару структур в процессе кодогенерации.
Также создаётся вызов макроопределения, создающего вспомогательные методы получения ключа и значения, соответствующих группе.
Исходный код функции выделения групп из списка столбцов таблицы приведен в листинге \ref{lst:groups.py}

\includelistingpretty
{groups.py}
{Python}
{Исходный код функции выделения групп}

\subsection{Выборка данных}
Результатом кодогенерации из SQL-выражения выборки данных является структура итератора языка \texttt{C++}, позволяющего производить обход всех результатов выборки в соответствии с общепринятыми стандартами программирования на этом языке.

В силу сложности самостоятельного формирования алгоритма обхода структуры данных на основе SQL-запроса, было решено генерировать алгоритм на языке \texttt{C++} на основе алгоритма, предлагаемого ядром базы данных SQLite для осуществления выборки в виде байткода \cite{sqlite_bytecode}.

В виртуальной машине SQLite для хранения промежуточных результатов используются пронумерованные регистры, которые решено симулировать в виде полей класса итератора.

Использование байткода SQLite в качестве основы для алгоритма сопряжено с трудностями, поскольку требует отказа от структурного подхода к программированию.
Это связано с тем, что многие алгоритмы, созданные SQLite требуют нетривиальные ветвления, которые трудно автоматически преобразовать к if.
Поэтому в сгенерированном коде итератора может применяться оператор \texttt{goto} языка \texttt{C++}.

Часть исходного кода функции сопоставления операций байткода SQLite и операций языка \texttt{C++} приведена в листинге \ref{lst:bytecode.py}. Полный листинг функции не приводится из-за её большого объёма.

\includelistingpretty
{bytecode.py}
{Python}
{Исходный код функции сопоставления байткода SQLite}


\subsection{Вставка данных}
Инструкция вставки языка SQL преобразуется в функцию вставки \texttt{lnh\_ins\_sync()} библиотеки \texttt{leonhard x64 xrt}.

При этом для каждой группы исходной таблицы происходит вставка одной строки в структуру, а разбиение вводимых данных на ключ и значение достигается при помощи проверки вхождения имени вставляемого столбца в первичный ключ.

Все связываемые параметры превращаются в аргументы функции в соответствии с порядком в заданном SQL-выражении, при этом учитывается только порядок первых вхождений связываемых параметров, а дубликаты игнорируются.

Исходный код метода формирования тела функции вставки данных в структуру хранения данных приведен в листинге \ref{lst:insert.py}.

\includelistingpretty
{insert.py}
{Python}
{Исходный код метода формироавния тела функции вставки}

\section{Интерфейс командной строки}
Разработанный интерфейс командной строки запрашивает у пользователя построчный ввод SQL-выражений и имени генерируемого объекта, после чего выводит текст на языке \texttt{C++}, соответствующий запросу.
Для завершения работы необходимо воспользоваться сочетанием клавиш \texttt{Ctrl + C}.
Пример работы с интерфейсом командной строки приведен на рисунке \ref{img:cli}.

\includeimage
{cli}
{f}
{H}
{0.8\textwidth}
{Работа с интерфейсом командной строки}

\section{Кодогенерация в файле исходного кода}
Для использования кодогенерации в файле исходного кода необходимо установить утилиту \texttt{Cog}.
Она требует размещения в файле исходного кода \texttt{C++} комментариев специального формата.

Каждый такой комментарий, содержащий исполняемый код на \texttt{Python} называется ячейкой.

В начале файла необходимо разместить ячейку, в которой происходит создание экземпляра генератора, поддерживающего подключение к указанному файлу базы данных SQLite -- листинг \ref{lst:cog_start.py}.

Это необходимо для создания сессии кодогенерации в контексте одного соединения с базой данных.

\includelistingpretty
{cog_start.py}
{Python}
{Ячейка инициализации кодогенератора}

Для генерации кода из SQL-выражения необходимо разместить ячейку с вызовом метода \texttt{translate} у экземпляра кодогенератора и передачей исходного SQL-выражения и желаемого имени объекта -- листинг \ref{lst:cog_create.py}.

\includelistingpretty
{cog_create.py}
{Python}
{Пример ячейки кодогенерации}

Разрыв соединения с экземпляром базы данных и его удаление происходит автоматически по окончанию работы с файлом исходного кода при помощи переопределенного деструктора класса \texttt{CogPrinter}.

\section*{Вывод по технологической части}
Была разработана программный модуль на языке \texttt{Python}, реализующий метод кодогенерации инструкций работы с графовой базой данных на основе SQL-выражений.
Разработан интерфейс командной строки и програмнный интерфейс для вызова механизма кодогенерации в качестве внешнего программного модуля из утилиты кодогенерации.